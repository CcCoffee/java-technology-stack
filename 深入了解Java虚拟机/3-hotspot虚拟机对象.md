## 一：对象的创建

![image-20190419142641530](https://ws2.sinaimg.cn/large/006tNc79ly1g27xd9mnrzj30w90u0n8d.jpg)

对象创建步骤：

1. 给对象分配内存

   ![image-20190419143003790](https://ws4.sinaimg.cn/large/006tNc79ly1g27xgr5v15j30yz0u0qei.jpg)

2. 线程安全性问题

   无论是指针碰撞还是空闲列表，在高并发情况下都有可能存在线程安全性问题。解决方案如下：

   - 加同步锁。安全但是执行效率低。
   - 本地线程分配缓冲。针对每个线程，给其在堆内存中单独分配一块区域，每个线程只能使用分配给自己的区域。我们称之为本地线程分配缓冲(Thread Local Aollocation Buffer )。

3. 初始化对象

   初始化对象头信息。

4. 执行构造方法

-----

## 二：对象的结构

 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。下图是普通对象实例与数组对象实例的数据结构：

![image-20190419143145083](https://ws3.sinaimg.cn/large/006tNc79ly1g27xijr4evj30zm0la7hj.jpg)

### 对象头

HotSpot虚拟机的对象头包括以下信息：

1. markword
   第一部分markword,用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“MarkWord”。
2. klass
   对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.
3. 数组长度（只有数组对象有）
   如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.

### 实例数据

​        实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

### 对齐填充

​        第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

-----

## 三：对象的访问定位

之前我们理解java栈堆时可能会说栈中存储指针，指向堆中的对象地址。其实这种说法是不严谨的，其一是java中没有指针的概念，其二是栈中不一定存储对象的地址，也可能是其他地址。那么问题来了，对象是如何进行访问定位的呢。

虚拟机栈是 java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
    
局部变量表存放了编译期可知的各种基本数据类型（long,boolean,int,byte,short,long,double,float）、returnAddress类型（指向了一条字节码指令的地址）和对象引用（reference类型，它不代表对象本身，可能是一个指向对象起始地址的引用指针，也可能指向一个对象代表的句柄或其他与此对象相关的位置）。
    
其实java就是通过 栈帧中局部变量表所存储的对象引用 来对 堆内存中的对象实例进行访问或操作的！简单点理解就是 栈帧中有个对象引用的指针， 通过各种方法指向了堆内存中的对象实例。而这各种方法中，主流的有2种：**句柄、直接指针**。

### **句柄**

 java堆中划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![image-20190419143431921](https://ws2.sinaimg.cn/large/006tNc79ly1g27xlem7nxj30xy0ecn2r.jpg)

使用句柄方式最大的好处就是reference中存储的是**稳定**的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

### **直接指针**

 reference直接指向了对象类型数据，那么java堆对象分布中就必须考虑如何放置访问类型数据的相关信息，

reference存储的直接就时对象地址。

![image-20190419143505051](https://ws3.sinaimg.cn/large/006tNc79ly1g27xlz5ytaj30yk0duq7w.jpg)

直接访问对象方式的好处就是，减少一次指针定位的时间开销，由于对象的访问是非常频繁的，因此这类开销积少成多也是一项非常的执行成本。

-----

