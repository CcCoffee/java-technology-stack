> 堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在堆进行回收前，第一件事就是确定这些对象之中哪些活着哪些死去。

## 一：引用计数法

引用计数算法作为垃圾收集器最早的算法，有其优势，也有其劣势，虽然现在的JVM都不再采用引用计数算法进行垃圾回收【例如Sun的Java hotspot采用了火车算法进行垃圾回收】，但这种算法也并未被淘汰，在著名的单进程高并发缓存Redis中依然采用这种算法来进行内存回收。

直白一点，引用计数算法就是对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数，垃圾收集器在进行垃圾回收时，对扫描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间,同时将该对象引用的其他对象的计数器进行减一操作。
    
优势：简单易于垃圾回收器判定。 
劣势：采用引用计数器进行垃圾回收，最大的缺点就是不能解决循环引用的问题，例如一个父对象持有一个子对象的引用，子对象也持有父对象的引用，这种情况下，父子对象将一直存在于JVM的堆中，无法进行回收。

接下来，我们写一个例子来佐证引用计数法的劣势，代码如下：

```java
public class Main {
	private Object instence;
 
	public Main() {
		//开辟一片20MB大小的内存，便于形象的看出释放效果
		byte [] b = new byte[20 * 1024 * 1024];
	}
 
	public static void main(String[] args) {
		//创建m1、m2.此时栈中有两个引用m1、m2分别指向堆中的两个Main中。
		Main m1 = new Main();
		Main m2 = new Main();
		
		//让堆中m1指向m2
		m1.instence = m2;
		//让堆中m2指向m1
		m2.instence = m1;
		
		//将栈队堆的引用断开
		m1 = null ;
		m2 = null ;
		
		//主动调用垃圾回收机制
		System.gc();
	}
 
}
```

运行结果：

![image-20190419145854509](https://ws3.sinaimg.cn/large/006tNc79ly1g27yarw2r8j31fq0daasg.jpg)

图中红框所示为回收前堆占用内存和回收后堆占用内存情况。 可以看出正好回收了40M，也就是两个Main的空间。因此可以得出结论：JDK8所采用的垃圾收集算法不是引用计数法。

-----

## 二：可达性分析法

在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。

![image-20190419152036668](https://ws3.sinaimg.cn/large/006tNc79ly1g27yxcgms8j30p00dgjum.jpg)

一般来说，如下情况的对象可以作为GC Roots：

1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI（Native方法）的引用的对象

-----

