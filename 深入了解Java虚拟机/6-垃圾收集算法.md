## 一：标记-清除算法

标记-清除算法是GC中最基础的算法。从名称上看，其可以拆分为两部分:标记(mark)和清除(sweep)。此算法可以分为两个阶段，一个是标记阶段，一个是清除阶段，下面就分别做一下介绍。

1. **标记阶段:**在此阶段，垃圾回收器会从mutator（应用程序）根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。
2. **清除阶段:**在此阶段中，垃圾回收器，会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。

图示如下:

![image-20190419152445789](https://ws2.sinaimg.cn/large/006tNc79ly1g27z1nww9yj319i0c4tbf.jpg)

在标记阶段，从根对象1可以访问到B，从B又可以访问到E，那么B和E都是可到达对象，同样的道理，F、G、J和K都是可到达对象。在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收。

> 注：在垃圾回收阶段，应用程序的执行会暂停，等待回收执行完毕后，再恢复程序的执行。

**何时开始垃圾回收:**

> 在使用标记清除算法时,未引用对象并不会被立即回收.取而代之的做法是,垃圾对象将一直累计到内存耗尽为止.当内存耗尽时,程序将会被挂起,垃圾回收开始执行。

**标记清除算法的优点:**

> ​    简单易实现；由于整个过程不移动对象，与保守式GC算法兼容(保守式GC算法不需要移动对象)；

**标记清除算法的缺点:**

> 1. 垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。
> 2. 回收效率不高(需要进行两次内存扫描，分别是标记阶段和清除阶段);

-------

## 二：复制算法

上一节我们讲到了标记-清除算法因为需要进行两次内存扫描导致效率不高，那么这一节我们介绍一种复制算法，比较好的解决了这个问题。

讲复制算法前，我们先回顾一下JVM的内存结构。JVM内存大体分为两大块，分别为线程共享区、线程独占区。其中线程共享区主要包括堆内存、方法区。线程独占区主要包括栈内存、本地方法栈、程序计数器。而我们垃圾回收主要针对的是线程共享区的堆内存。

为了方便垃圾回收，我们的的堆内存又分为两块区域，新生代和老年代。为什么要这么问，接下来讲复制算法时候会细细道来。那么新生代又会被分为四块区域：Eden(伊甸园)[内存占比80%]、Survival1(存活区1)[内存占比10%]、Survival2(存活区2)[内存占比10%]、Tenured(终身区)[担保内存区，额外空间]。那么问题来了，这四个区域是怎么和复制算法完美契合的呢。接下来结合复制算法的逻辑做以下说明：

1. 刚开始创建的新对象会被放入Eden
2. 垃圾回收机制被触发，垃圾回收器扫描Eden(伊甸园)、Survival1(存活区1)中可被回收的对象将其回收。将不可被回收的对象复制到Survival2(存活区2)中。
3. 下一次垃圾回收机制被触发，垃圾回收器扫描Eden(伊甸园)、Survival2(存活区2)中可被回收的对象将其回收。将不可被回收的对象复制到Survival1(存活区1)中。
4. 当扫描Survival中对象若还不可被回收则可能将其放入Tenured(终身区)中。
5. 以此往复扫描Eden(伊甸园)和Survival中的一个区域。将存活对象放入Survival中另外一个区域中。

示意图：

![image-20190419152833433](https://ws3.sinaimg.cn/large/006tNc79ly1g27z5mabqsj317c0p8jv4.jpg)

-----

## 三：标记整理算法

复制算法在存货对象较多时需要执行大量的复制操作，这对老年代来说是不合适的，因此有人就提出了标记-整理算法，过程与标记-清除算法一样，但后续步骤不是对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉边界之外的内存。

![image-20190419153034080](https://ws1.sinaimg.cn/large/006tNc79ly1g27z7prefij313i0luk17.jpg)

---

## 四：分代收集算法

当前的商业虚拟机均使用分代收集算法，将对象按照存活周期分为几块，一般将Java堆分为新生代与老年代，从而可以根据不同年代的特点使用不同的收集算法。

如新生代中存在大量死去的对象，只有少量存活，使用复制算法；老年代中因存活对象数量多，且没有额外空间，因此需要采用标记 - 清除或 标记 - 清理算法。

---

## 五：主流垃圾收集器

### Serial收集器

**特点：**

1、最基本、发展最悠久

2、单线程垃圾收集器

要理解单线程垃圾收集器，可以举例如下图所示。从图中我们可以看出，当JVM需要进行垃圾回收时候，需要将正在运行的所有线程全部终止才可以。

![image-20190419153245779](https://ws4.sinaimg.cn/large/006tNc79ly1g27z9zka5pj30t80fq40x.jpg)

**用途：**

客户端场景使用。因为客户端分配内存少，收集过程很快，且可以减少线程开销.

----

### parnew收集器

ParNew收集器是JAVA虚拟机中垃圾收集器的一种。它是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器一致。

ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器，在JDK1.6以及之前的版本中，除了Serial收集器外，只有它能与CMS收集器配合工作。

在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。

所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器也是使用 -XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC选项来强制指定它。

---

### parallel Scavenge收集器

Parallel Scavenge收集器是Java虚拟机中垃圾收集器的一种。又称为吞吐量优先收集器,和ParNew收集器类似，是一个新生代收集器。使用复制算法的并行多线程收集器。而且是并行的多多线程收集器。java1.8默认的收集器就是parallel Scavenge。

Parallel Scavenge收集器的**关注点与其他收集器不同**， ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）

> **吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)**

为了实现吞吐量的可控，parallel Scavenge收集器提供了三个重要参数。

1. **控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数:**MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

2. **直接设置吞吐量大小的 -XX:GCTimeRatio参数:**GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。

3. **UseAdaptiveSizePolicy开关参数:**-XX:+UseAdaptiveSizePolicy是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。

**自适应调节策略:**

除过上述参数外，Parallel Scavenge收集器还能够配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio参数（更关注吞吐量）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

-----

### **cms收集器（Concurrent Mark-Sweep）**

CMS是一个并发收集器，用于收集老年代内存。

**工作过程：**

1. 初始标记(CMS-initial-mark) ,会导致swt；标记老年代中所有的GC Roots对象
2. 并发标记(CMS-concurrent-mark)，与用户线程同时运行；从“初始标记”阶段标记的对象开始找出所有存活的对象;
3. 预清理（CMS-concurrent-preclean），与用户线程同时运行；
4. 可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；
5. 重新标记(CMS-remark) ，会导致swt；
6. 并发清除(CMS-concurrent-sweep)，与用户线程同时运行；
7. 并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；

cms运行流程图如下所示：

![image-20190419153648081](https://ws4.sinaimg.cn/large/006tNc79ly1g27ze79ugoj31440isawu.jpg)

###G1集器

G1（Garbage First）收集器是最新的GC 收集器，其基于标记 - 整理算法，并且可以非常精确的控制停顿

----

